{"name":"Ohm ॐ","body":"Object-Hash Mapping for Redis\r\n=============================\r\n\r\nOhm is a library for storing objects in [Redis][redis], a persistent key-value\r\ndatabase. It includes an extensible list of validations and has very good\r\nperformance.\r\n\r\nCommunity\r\n---------\r\n\r\nJoin the mailing list: [http://groups.google.com/group/ohm-ruby](http://groups.google.com/group/ohm-ruby)\r\n\r\nMeet us on IRC: [#ohm](irc://chat.freenode.net/#ohm) on [freenode.net](http://freenode.net/)\r\n\r\n\r\nRelated projects\r\n----------------\r\n\r\nThese are libraries in other languages that were inspired by Ohm.\r\n\r\n* [JOhm](https://github.com/xetorthio/johm) for Java, created by xetorthio\r\n* [Lohm](https://github.com/slact/lua-ohm) for Lua, created by slact\r\n* [Nohm](https://github.com/maritz/nohm) for Node.js, created by maritz\r\n* [Redisco](https://github.com/iamteem/redisco) for Python, created by iamteem\r\n\r\nArticles and Presentations\r\n--------------------------\r\n\r\n* [Simplicty](http://files.soveran.com/simplicity)\r\n* [How to Redis](http://www.paperplanes.de/2009/10/30/how_to_redis.html)\r\n* [Redis and Ohm](http://carlopecchia.eu/blog/2010/04/30/redis-and-ohm-part1/)\r\n* [Ohm (Redis ORM)](http://blog.s21g.com/articles/1717) (Japanese)\r\n* [Redis and Ohm](http://www.slideshare.net/awksedgreep/redis-and-ohm)\r\n* [Ruby off Rails](http://www.slideshare.net/cyx.ucron/ruby-off-rails)\r\n\r\nGetting started\r\n---------------\r\n\r\nInstall [Redis][redis]. On most platforms it's as easy as grabbing the sources,\r\nrunning make and then putting the `redis-server` binary in the PATH.\r\n\r\nOnce you have it installed, you can execute `redis-server` and it will\r\nrun on `localhost:6379` by default. Check the `redis.conf` file that comes\r\nwith the sources if you want to change some settings.\r\n\r\nIf you don't have Ohm, try this:\r\n\r\n    $ [sudo] gem install ohm\r\n\r\nOr you can grab the code from [http://github.com/soveran/ohm][ohm].\r\n\r\nNow, in an irb session you can test the Redis adapter directly:\r\n\r\n    >> require \"ohm\"\r\n    => true\r\n    >> Ohm.connect\r\n    => []\r\n    >> Ohm.redis.set \"Foo\", \"Bar\"\r\n    => \"OK\"\r\n    >> Ohm.redis.get \"Foo\"\r\n    => \"Bar\"\r\n\r\n## Connecting to the Redis database\r\n\r\nThere are a couple of different strategies for connecting to your Redis\r\ndatabase. The first is to explicitly set the `:host`, `:port`, `:db` and\r\n`:timeout` options. You can also set only a few of them, and let the other\r\noptions fall back to the default.\r\n\r\nThe other noteworthy style of connecting is by just doing `Ohm.connect` and\r\nset the environment variable `REDIS_URL`.\r\n\r\nHere are the options for {Ohm.connect} in detail:\r\n\r\n### :url\r\n\r\nA Redis URL of the form `redis://:<passwd>@<host>:<port>/<db>`.\r\nNote that if you specify a URL and one of the other options at\r\nthe same time, the other options will take precedence. Also, if\r\nyou try and do `Ohm.connect` without any arguments, it will check\r\nif `ENV[\"REDIS_URL\"]` is set, and will use it as the argument for\r\n`:url`.\r\n\r\n### :host\r\n\r\nHost where the Redis server is running, defaults to `\"127.0.0.1\"`.\r\n\r\n### :port\r\n\r\nPort number, defaults to `6379`.\r\n\r\n### :db\r\n\r\nDatabase number, defaults to `0`.\r\n\r\n### :password\r\n\r\nIt is the secret that will be sent to the Redis server. Use it if the server\r\nconfiguration requires it. Defaults to `nil`.\r\n\r\n### :timeout\r\n\r\nDatabase timeout in seconds, defaults to `0`.\r\n\r\n### :thread_safe\r\n\r\nInitializes the client with a monitor. It has a small performance penalty, and\r\nit's off by default. For thread safety, it is recommended to use a different\r\ninstance per thread. I you have no choice, then pass `:thread_safe => true`\r\nwhen connecting.\r\n\r\nModels\r\n------\r\n\r\nOhm's purpose in life is to map objects to a key value datastore. It\r\ndoesn't need migrations or external schema definitions. Take a look at\r\nthe example below:\r\n\r\n### Example\r\n\r\n```ruby\r\nclass Event < Ohm::Model\r\n  attribute :name\r\n  reference :venue, Venue\r\n  set :participants, Person\r\n  counter :votes\r\n\r\n  index :name\r\n\r\n  def validate\r\n    assert_present :name\r\n  end\r\nend\r\n\r\nclass Venue < Ohm::Model\r\n  attribute :name\r\n  collection :events, Event\r\nend\r\n\r\nclass Person < Ohm::Model\r\n  attribute :name\r\nend\r\n```\r\n\r\nAll models have the `id` attribute built in, you don't need to declare it.\r\n\r\nThis is how you interact with IDs:\r\n\r\n```ruby\r\nevent = Event.create :name => \"Ohm Worldwide Conference 2031\"\r\nevent.id\r\n# => 1\r\n\r\n# Find an event by id\r\nevent == Event[1]\r\n# => true\r\n\r\n# Trying to find a non existent event\r\nEvent[2]\r\n# => nil\r\n\r\n# Finding all the events\r\nEvent.all\r\n# => [#<Event @values={:id=>1, :name=>\"Ohm Worldwide Conference 2031\"}>]\r\n```\r\n\r\nThis example shows some basic features, like attribute declarations and\r\nvalidations. Keep reading to find out what you can do with models.\r\n\r\nAttribute types\r\n---------------\r\n\r\nOhm::Model provides four attribute types: {Ohm::Model.attribute\r\nattribute}, {Ohm::Model.set set}, {Ohm::Model.list list}\r\nand {Ohm::Model.counter counter}; and two meta types:\r\n{Ohm::Model.reference reference} and {Ohm::Model.collection\r\ncollection}.\r\n\r\n### attribute\r\n\r\nAn `attribute` is just any value that can be stored as a string. In the\r\nexample above, we used this field to store the event's `name`. You can\r\nuse it to store numbers, but be aware that Redis will return a string\r\nwhen you retrieve the value.\r\n\r\n### set\r\n\r\nA `set` in Redis is an unordered list, with an external behavior similar\r\nto that of Ruby arrays, but optimized for faster membership lookups.\r\nIt's used internally by Ohm to keep track of the instances of each model\r\nand for generating and maintaining indexes.\r\n\r\n### list\r\n\r\nA `list` is like an array in Ruby. It's perfectly suited for queues\r\nand for keeping elements in order.\r\n\r\n### counter\r\n\r\nA `counter` is like a regular attribute, but the direct manipulation\r\nof the value is not allowed. You can retrieve, increase or decrease\r\nthe value, but you can not assign it. In the example above, we used a\r\ncounter attribute for tracking votes. As the incr and decr operations\r\nare atomic, you can rest assured a vote won't be counted twice.\r\n\r\n### reference\r\n\r\nIt's a special kind of attribute that references another model.\r\nInternally, Ohm will keep a pointer to the model (its ID), but you get\r\naccessors that give you real instances. You can think of it as the model\r\ncontaining the foreign key to another model.\r\n\r\n### collection\r\n\r\nProvides an accessor to search for all models that `reference` the current model.\r\n\r\nPersistence strategy\r\n--------------------\r\n\r\nThe attributes declared with `attribute` are only persisted after\r\ncalling `save`. If the object is in an invalid state, no value is sent\r\nto Redis (see the section on **Validations** below).\r\n\r\nOperations on attributes of type `list`, `set` and `counter` are\r\npossible only after the object is created (when it has an assigned\r\n`id`). Any operation on these kinds of attributes is performed\r\nimmediately, without running the object validations. This design yields\r\nbetter performance than running the validations on each operation or\r\nbuffering the operations and waiting for a call to `save`.\r\n\r\nFor most use cases, this pattern doesn't represent a problem.\r\nIf you need to check for validity before operating on lists, sets or\r\ncounters, you can use this pattern:\r\n\r\n```ruby\r\nif event.valid?\r\n  event.comments.add(Comment.create(:body => \"Great event!\"))\r\nend\r\n```\r\n\r\nIf you are saving the object, this will suffice:\r\n\r\n```ruby\r\nif event.save\r\n  event.comments.add(Comment.create(:body => \"Wonderful event!\"))\r\nend\r\n```\r\n\r\nWorking with Sets\r\n-----------------\r\n\r\nGiven the following model declaration:\r\n\r\n```ruby\r\nclass Event < Ohm::Model\r\n  attribute :name\r\n  set :attendees, Person\r\nend\r\n```\r\n\r\nYou can add instances of `Person` to the set of attendees with the\r\n`add` method:\r\n\r\n```ruby\r\nevent.attendees.add(Person.create(:name => \"Albert\"))\r\n\r\n# And now...\r\nevent.attendees.each do |person|\r\n  # ...do what you want with this person.\r\nend\r\n```\r\n\r\n## Sorting\r\n\r\nSince `attendees` is a {Ohm::Model::Set Set}, it exposes two sorting\r\nmethods: {Ohm::Model::Collection#sort sort} returns the elements\r\nordered by `id`, and {Ohm::Model::Collection#sort_by sort_by} receives\r\na parameter with an attribute name, which will determine the sorting\r\norder. Both methods receive an options hash which is explained below:\r\n\r\n### :order\r\n\r\nOrder direction and strategy. You can pass in any of the following:\r\n\r\n1. ASC\r\n2. ASC ALPHA (or ALPHA ASC)\r\n3. DESC\r\n4. DESC ALPHA (or ALPHA DESC)\r\n\r\nIt defaults to `ASC`.\r\n\r\n__Important Note:__ Starting with Redis 2.6, `ASC` and `DESC` only\r\nwork with integers or floating point data types. If you need to sort\r\nby an alphanumeric field, add the `ALPHA` keyword.\r\n\r\n### :limit\r\n\r\nThe offset and limit from which we should start with. Note that\r\nthis is 0-indexed. It defaults to `0`.\r\n\r\nExample:\r\n\r\n`limit: [0, 10]` will get the first 10 entries starting from offset 0.\r\n\r\n### :by\r\n\r\nKey or Hash key with which to sort by. An important distinction with\r\nusing {Ohm::Model::Collection#sort sort} and\r\n{Ohm::Model::Collection#sort_by sort_by} is that `sort_by` automatically\r\nconverts the passed argument with the assumption that it is a hash key\r\nand it's within the current model you are sorting.\r\n\r\n```ruby\r\nPost.all.sort_by(:title)     # SORT Post:all BY Post:*->title\r\nPost.all.sort(:by => :title) # SORT Post:all BY title\r\n```\r\n\r\n__Tip:__ Unless you absolutely know what you're doing, use `sort`\r\nwhen you want to sort your models by their `id`, and use `sort_by`\r\notherwise.\r\n\r\n### :get\r\n\r\nA key pattern to return, e.g. `Post:*->title`. As is the case with\r\nthe `:by` option, using {Ohm::Model::Collection#sort sort} and\r\n{Ohm::Model::Collection#sort_by sort_by} has distinct differences in\r\nthat `sort_by` does much of the hand-coding for you.\r\n\r\n```ruby\r\nPost.all.sort_by(:title, :get => :title)\r\n# SORT Post:all BY Post:*->title GET Post:*->title\r\n\r\nPost.all.sort(:by => :title, :get => :title)\r\n# SORT Post:all BY title GET title\r\n```\r\n\r\n\r\nAssociations\r\n------------\r\n\r\nOhm lets you declare `references` and `collections` to represent associations.\r\n\r\n```ruby\r\nclass Post < Ohm::Model\r\n  attribute :title\r\n  attribute :body\r\n  collection :comments, Comment\r\nend\r\n\r\nclass Comment < Ohm::Model\r\n  attribute :body\r\n  reference :post, Post\r\nend\r\n```\r\n\r\nAfter this, every time you refer to `post.comments` you will be talking\r\nabout instances of the model `Comment`. If you want to get a list of IDs\r\nyou can use `post.comments.key.smembers`.\r\n\r\n### References explained\r\n\r\nDoing a {Ohm::Model.reference reference} is actually just a shortcut for\r\nthe following:\r\n\r\n```ruby\r\n# Redefining our model above\r\nclass Comment < Ohm::Model\r\n  attribute :body\r\n  attribute :post_id\r\n  index :post_id\r\n\r\n  def post=(post)\r\n    self.post_id = post.id\r\n  end\r\n\r\n  def post\r\n    Post[post_id]\r\n  end\r\nend\r\n```\r\n\r\nThe only difference with the actual implementation is that the model\r\nis memoized.\r\n\r\nThe net effect here is we can conveniently set and retrieve `Post` objects,\r\nand also search comments using the `post_id` index.\r\n\r\n```ruby\r\nComment.find(:post_id => 1)\r\n```\r\n\r\n### Collections explained\r\n\r\nThe reason a {Ohm::Model.reference reference} and a\r\n{Ohm::Model.collection collection} go hand in hand, is that a collection is\r\njust a macro that defines a finder for you, and we know that to find a model\r\nby a field requires an {Ohm::Model.index index} to be defined for the field\r\nyou want to search.\r\n\r\n```ruby\r\n# Redefining our post above\r\nclass Post < Ohm::Model\r\n  attribute :title\r\n  attribute :body\r\n\r\n  def comments\r\n    Comment.find(:post_id => self.id)\r\n  end\r\nend\r\n```\r\n\r\nThe only \"magic\" happening is with the inference of the `index` that was used\r\nin the other model. The following all produce the same effect:\r\n\r\n```ruby\r\n# easiest, with the basic assumption that the index is `:post_id`\r\ncollection :comments, Comment\r\n\r\n# we can explicitly declare this as follows too:\r\ncollection :comments, Comment, :post\r\n\r\n# finally, we can use the default argument for the third parameter which\r\n# is `to_reference`.\r\ncollection :comments, Comment, to_reference\r\n\r\n# exploring `to_reference` reveals a very interesting and simple concept:\r\nPost.to_reference == :post\r\n# => true\r\n```\r\n\r\nIndices\r\n-------\r\n\r\nAn {Ohm::Model.index index} is a set that's handled automatically by Ohm. For\r\nany index declared, Ohm maintains different sets of objects IDs for quick\r\nlookups.\r\n\r\nIn the `Event` example, the index on the name attribute will\r\nallow for searches like `Event.find(:name => \"some value\")`.\r\n\r\nNote that the {Ohm::Model::Validations#assert_unique assert_unique}\r\nvalidation and the methods {Ohm::Model::Set#find find} and\r\n{Ohm::Model::Set#except except} need a corresponding index in order to work.\r\n\r\n### Finding records\r\n\r\nYou can find a collection of records with the `find` method:\r\n\r\n```ruby\r\n# This returns a collection of users with the username \"Albert\"\r\nUser.find(:username => \"Albert\")\r\n```\r\n\r\n### Filtering results\r\n\r\n```ruby\r\n# Find all users from Argentina\r\nUser.find(:country => \"Argentina\")\r\n\r\n# Find all activated users from Argentina\r\nUser.find(:country => \"Argentina\", :status => \"activated\")\r\n\r\n# Find all users from Argentina, except those with a suspended account.\r\nUser.find(:country => \"Argentina\").except(:status => \"suspended\")\r\n\r\n# Find all users both from Argentina and Uruguay\r\nUser.find(:country => \"Argentina\").union(:country => \"Uruguay\")\r\n```\r\n\r\nNote that calling these methods results in new sets being created\r\non the fly. This is important so that you can perform further operations\r\nbefore reading the items to the client.\r\n\r\nFor more information, see [SINTERSTORE](http://redis.io/commands/sinterstore),\r\n[SDIFFSTORE](http://redis.io/commands/sdiffstore) and\r\n[SUNIONSTORE](http://redis.io/commands/sunionstore)\r\n\r\nUniques\r\n-------\r\n\r\nUniques are similar to indices except that there can only be one record per\r\nentry. The canonical example of course would be the email of your user, e.g.\r\n\r\n```ruby\r\nclass User < Ohm::Model\r\n  attribute :email\r\n  unique :email\r\nend\r\n\r\nu = User.create(email: \"foo@bar.com\")\r\nu == User.with(:email, \"foo@bar.com\")\r\n# => true\r\n\r\nUser.create(email: \"foo@bar.com\")\r\n# => raises Ohm::UniqueIndexViolation\r\n```\r\n\r\nValidations\r\n-----------\r\n\r\nBefore every save, the `validate` method is called by Ohm. In the method\r\ndefinition you can use assertions that will determine if the attributes\r\nare valid. Nesting assertions is a good practice, and you are also\r\nencouraged to create your own assertions. You can trigger validations at\r\nany point by calling `valid?` on a model instance.\r\n\r\nAssertions\r\n-----------\r\n\r\nOhm ships with some basic assertions. Check Ohm::Validations to see\r\nthe method definitions.\r\n\r\n### assert\r\n\r\nThe `assert` method is used by all the other assertions. It pushes the\r\nsecond parameter to the list of errors if the first parameter evaluates\r\nto false.\r\n\r\n```ruby\r\ndef assert(value, error)\r\n  value or errors.push(error) && false\r\nend\r\n```\r\n\r\n### assert_present\r\n\r\nChecks that the given field is not nil or empty. The error code for this\r\nassertion is `:not_present`.\r\n\r\n```ruby\r\nassert_present :name\r\n```\r\n\r\n### assert_format\r\n\r\nChecks that the given field matches the provided format. The error code\r\nfor this assertion is :format.\r\n\r\n```ruby\r\nassert_format :username, /^\\w+$/\r\n```\r\n\r\n### assert_numeric\r\n\r\nChecks that the given field holds a number as a Fixnum or as a string\r\nrepresentation. The error code for this assertion is :not_numeric.\r\n\r\n```ruby\r\nassert_numeric :votes\r\n```\r\n\r\nErrors\r\n------\r\n\r\nWhen an assertion fails, the error report is added to the errors array.\r\nEach error report contains two elements: the field where the assertion\r\nwas issued and the error code.\r\n\r\n### Validation example\r\n\r\nGiven the following example:\r\n\r\n```ruby\r\ndef validate\r\n  assert_present :foo\r\n  assert_numeric :bar\r\n  assert_format :baz, /^\\d{2}$/\r\nend\r\n```\r\n\r\nIf all the assertions fail, the following errors will be present:\r\n\r\n```ruby\r\nobj.errors\r\n# => { foo: [:not_present], bar: [:not_numeric], baz: [:format] }\r\n```\r\n\r\nOhm Extensions\r\n==============\r\n\r\nOhm is rather small and can be extended in many ways.\r\n\r\nA lot of amazing contributions are available at [Ohm Contrib][contrib]\r\nmake sure to check them if you need to extend Ohm's functionality.\r\n\r\n[contrib]: http://cyx.github.com/ohm-contrib/doc/, \r\n\r\nTutorials\r\n=========\r\n\r\nNOTE: These tutorials were written against Ohm 0.1.x. Please give us\r\na while to fully update all of them.\r\n\r\nCheck the examples to get a feeling of the design patterns for Redis.\r\n\r\n1. [Activity Feed](http://ohm.keyvalue.org/examples/activity-feed.html)\r\n2. [Chaining finds](http://ohm.keyvalue.org/examples/chaining.html)\r\n3. [Serialization to JSON](http://ohm.keyvalue.org/examples/json-hash.html)\r\n4. [One to many associations](http://ohm.keyvalue.org/examples/one-to-many.html)\r\n5. [Philosophy behind Ohm](http://ohm.keyvalue.org/examples/philosophy.html)\r\n6. [Learning Ohm internals](http://ohm.keyvalue.org/examples/redis-logging.html)\r\n7. [Slugs and permalinks](http://ohm.keyvalue.org/examples/slug.html)\r\n8. [Tagging](http://ohm.keyvalue.org/examples/tagging.html)\r\n\r\n\r\nVersions\r\n========\r\n\r\nOhm uses features from Redis > 2.6.x. If you are stuck in previous\r\nversions, please use Ohm 0.1.x instead.\r\n\r\nUpgrading from 0.0.x to 0.1\r\n---------------------------\r\n\r\nSince Ohm 0.1 changes the persistence strategy (from 1-key-per-attribute\r\nto Hashes), you'll need to run a script to upgrade your old data set.\r\nFortunately, it is built in:\r\n\r\n```ruby\r\nrequire \"ohm/utils/upgrade\"\r\n\r\nOhm.connect :port => 6380\r\n\r\nOhm::Utils::Upgrade.new([:User, :Post, :Comment]).run\r\n```\r\n\r\nYes, you need to provide the model names. The good part is that you\r\ndon't have to load your application environment. Since we assume it's\r\nvery likely that you have a bunch of data, the script uses\r\n[Batch](http://github.com/djanowski/batch) to show you some progress\r\nwhile the process runs.\r\n\r\n\r\n[redis]: http://redis.io\r\n[ohm]: http://github.com/soveran/ohm\r\n","tagline":"Object-Hash Mapping for Redis","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}